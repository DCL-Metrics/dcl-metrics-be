date = '2022-09-03'

# NOTE: the following two querys should just be one join query
cids = DATABASE_CONNECTION[
  "select distinct scene_cid
  from peer_stats
  where date = '#{date}'"
].all.flat_map(&:values)

# scenes.count is DailyStats#total_active_scenes
scenes = Models::Scene.where(cid: cids).uniq { |s| [s.name, s.parcels] }
# should also remove public roads from here for better count

###################################
cids_by_scene = scenes.
  group_by { |s| [s.name, s.parcels] }.
  map { |group, data| [group.first, JSON.parse(group.last), data.flat_map(&:cid)] }

cids_by_scene.each do |name, parcels, cids|
  next if scene_is_a_public_road? # compare to tiles.json parcel type?

  stats = JSON.parse(scene.parcels).map do |coordinates|
    traffic = Models::ParcelTraffic.find(coordinates: coordinates, date: date)

    # number of unique addresses per parcel
    # histogram per parcel (maybe better to also switch this to using peer_stats)
  end

  # histogram overall (highest count per hour over the whole scene)
  # number of unique addresses overall
  # maybe can map all of the datapoints in this scene and create
  # * logins
  # * logouts
  # * total_time_spent
  # * avg_time_spent
  # * avg_time_spent_afk

end



# scenes / visitors:
parcel_traffic = Models::ParcelTraffic.where(coordinates: cids_by_scene[1])
parcel_traffic.map(&:unique_addresses).max

# maybe better to sort by unique addresses per day and then find the scenes that
# they belong to for "top scenes by visitor"

